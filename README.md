# Comparative a run-time analysis of object-oriented languages and functional language

This is an experimental study that I carried for British Conference of Undergraduate Research 2018. 

## Abstract:

Many programming languages exist today: C, C++, Python, Ruby, Haskell, Java, and so on. With so many languages, how does a software engineer decide which one to use for a project? Furthermore, there are a couple different programming paradigms: imperative, logical, object-oriented, and functional. So long, programming paradigms have been a key consideration for which programming language should be used for the task. However, in recent years, modern-high level languages have started having functional programming features. As a consequence, modern programming languages are becoming more like hybrid language. In an ideal world, a programming language should be chosen based on its performance. 

There is a wide range of research that has analysed run-time of sorting algorithm, execution time of sorting algorithms that implemented in different programming languages. However, it lacks a comparative study that analysed the performance of pure functional programming language and imperative programming language. Also, some of the programming languages which have already functional programming feature, such as lambda expressions, has not been analysed thoroughly yet.

So in this study, run-time analysis of basic, yet an industry standard, sorting algorithms are going to be presented. Performance of C++, Java, Python, Ruby and Haskell will be analysed with sorting algorithms such as insertion, mergesort, quicksort, heapsort, and selection sort. Also, a performance of sorting algorithms of object-oriented languages that have functional programming features. To conclude, I hope that this analysis would present a clear view of the performance of selected programming languages.


## Link to poster:
[Click here to see the poster](../blob/master/Poster.pdf)


## Results:
![alt text](https://github.com/Tumurtogtokh/BCUR2018/blob/master/n2.jpg "Figure 01: Comparison of O(n2) sorting algorithms with built-in sort (second)")
Figure 01: Comparison of O(n2) sorting algorithms with built-in sort (second)

![alt text](https://github.com/Tumurtogtokh/BCUR2018/blob/master/nlogn.jpg "Figure 02: Comparison of n2 sorting algorithms with built-in sort (second)")
Figure 02: Comparison of n2 sorting algorithms with built-in sort (second)

![alt text](https://github.com/Tumurtogtokh/BCUR2018/blob/master/sort.jpg "Figure 03: Comparison of built-in sort function and quicksort implementation (second)")
Figure 03: Comparison of built-in sort function and quicksort implementation (second)


## Full report:
(to be written soon. It will be finished by July 2018 when exams are over.)


## Update:
* 13.04.2018 - Code is released.
* 18.04.2018 - Poster is uploaded.


## To do:
* Write comments in code
* Write documentation at least most basic
* Include optimised Haskell codes
* Include functional implementation of Java. Testing is required.


